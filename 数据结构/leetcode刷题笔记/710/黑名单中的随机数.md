# leetcode刷题笔记之-710黑名单中的随机数------我终于弄懂了官方解题思路。



地址：https://leetcode-cn.com/problems/random-pick-with-blacklist/

## 题目描述：

> 给定一个包含 [0，n) 中不重复整数的黑名单 blacklist ，写一个函数从 [0, n) 中返回一个不在 blacklist 中的随机整数。
>
> 对它进行优化使其尽量少调用系统方法 Math.random() 。
>
> 提示:
>
> 1 <= n <= 1000000000
> 0 <= blacklist.length < min(100000, N)
> [0, n) 不包含 n ，详细参见 interval notation 。
> 示例 1：
>
> 输入：
> ["Solution","pick","pick","pick"]
> [[1,[]],[],[],[]]
> 输出：[null,0,0,0]
> 示例 2：
>
> 输入：
> ["Solution","pick","pick","pick"]
> [[2,[]],[],[],[]]
> 输出：[null,1,1,1]
> 示例 3：
>
> 输入：
> ["Solution","pick","pick","pick"]
> [[3,[1]],[],[],[]]
> 输出：[null,0,0,2]
> 示例 4：
>
> 输入： 
> ["Solution","pick","pick","pick"]
> [[4,[2]],[],[],[]]
> 输出：[null,1,3,1]
> 输入语法说明：
>
> 输入是两个列表：调用成员函数名和调用的参数。Solution的构造函数有两个参数，n 和黑名单 blacklist。pick 没有参数，输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表

## 题目解析：

题目的意思还是非常明确，但是在看到示例的时候却让人感觉莫不这头脑：这里在简单说明一下。

输入： 
["Solution","pick","pick","pick"] 
[[4,[2]],[],[],[]]
输出：[null,1,3,1]
 **解释：意思是会调用一次 Solution 构造函数 三次pick函数；调用 Solution 构造函数时长度的参数是 4，[2];调用pick时未传参数。**

# 官方三种解题方法解析

说实话我在拿到题目的时候只能想到第一种解题方法，不知道你们能想到那些呢？

## 解题方法1：维护白名单 

> 如果我们有了白名单（即黑名单之外的所有整数），那么我们就可以在白名单中随机选取整数并返回了。
>
> 我们首先在集合中放入 [0, N) 中的所有整数，随后移除所有在黑名单中出现过的数，并把剩下的数放入列表中，就得到了白名单。

leetcode官方代码：

```java
class Solution {

    List<Integer> w;
    Random r;

    public Solution(int n, int[] b) {
        w = new ArrayList<>();
        r = new Random();
        Set<Integer> W = new HashSet<>();
        //现将所有数据加入到白名单中
        for (int i = 0; i < n; i++) W.add(i);
        //将黑名单中的数移除
        for (int x : b) W.remove(x);
        //构建真正的白名单
        w.addAll(W);
    }

    public int pick() {
        return w.get(r.nextInt(w.size()));
    }
}
```

## 解题方法2：二分查找法

官方题解：

![](D:\workspace\android-Advanced-plan\数据结构\leetcode刷题笔记\710\二分法官方题解.png)

问题：

1. 为什么 mid = (lo + hi + 1) / 2   而不是   mid = (lo + hi ) / 2
2. c = B[mid] - mid 表示 在总名单上 黑名单前面可以插入的白名单数量（总名单可以理解成[0,n)的列表）。为什么c是和k比较
3. 为什么二分法查找结束之后会出现官方的现象

带着上面的问题我们来尝试自己写二分查找。

**理解 c = B[mid] - mid   在总名单T 上  T[mid] = mid 就像官方图上一样  B[1] = 2; 2-1 = 1 即B[1] 前可以插入一个白名单数**

我们知道在这个位置二分查找结束的标志是lo==hi  即二分查找的高低位相等，那么我们怎么确定第K个白名单数是落在总名单上B[lo]的左侧还是右侧呢？

![](D:\workspace\android-Advanced-plan\数据结构\leetcode刷题笔记\710\二分查找k掉落位置问题.png)

这个时候最终是选取黑名单的3还是5呢？我们知道在二分法查找的过程中 如果  mid = (lo + hi + 1) / 2  那么当总是为偶数个的时候中点会选取考右那个，mid = (lo + hi ) / 2 中点会选取靠左那个。**也就意味着如果我们要选取3那么 应该使用 mid = (lo + hi ) / 2  。我们要选取5就应该使用 mid = (lo + hi + 1) / 2。即如果要第k个白名单数落在黑名单的右边 mid = (lo + hi ) / 2  左边    mid = (lo + hi + 1) / 2**

### 第k个白名单数据的计算方式

![](二分法计算.png)

1.k落在黑名单左侧，特殊情况黑名单的最大数都比第k个白名单小  

注意下下面的话可能不是太好理解：  第h黑名单前能个插入白名单总数 preCountW 个，在总名单上第h个黑名单数的左侧第一个就是第 preCountW -1 个白名单数，那么第k个白名单就是第h个黑名单的值 -  (preCountW - k ) ;如果处于特殊情况  那么 第k个白名单 = 第h个黑名单的值 + k - preCountW 

代码如下：





2.k落在黑名单右侧，特殊情况黑名单的最小数都比第k个白名单大



## 解题方法3：黑名单映射

