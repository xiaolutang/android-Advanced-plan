我们知道一般而言图片加载框架会有三级缓存来进行图片加载。内存缓存  文件缓存 网络。在[Glide DecodeJob 的工作过程](https://juejin.cn/post/7035932291536797727)我们知道Glide将文件缓存分成了资源缓存和原始数据缓存。今天我们来研究下Glide的内存缓存相关的内容。

今天的源码阅读有三个目标

1. 了解活动资源缓存
2. 了解LRU缓存
3. Bitmap重用池技术

Glide图片的请发始于Engine#load方法它的加载流程如下

1. 从活动资源中获取图片
2. 如果活动资源当中没有图片，从内存缓存中获取
3. 内存缓存中没有图片，调用EngineJob DecodeJob  从文件或者网络获取图片。

这里我们只关心如何从内存当中获取图片

```java
//构建缓存的Key 
EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
        resourceClass, transcodeClass, options);
//从活动资源当中获取
    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
      }
      return null;
    }
//从Lru缓存当中获取图片
    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from cache", startTime, key);
      }
      return null;
    }
//后续从文件或者网络当中获取图片
```

# 活动资源缓存

可能初看到这个名字的小伙伴有点懵，什么是活动资源缓存？我的理解是当前没有被销毁的页面所使用的图片。活动资源缓存涉及到两个关键类EngineResource和ActiveResources。EngineResource作为被缓存的对象，ActiveResources缓存活动资源的集合。

## EngineResource

EngineResource是一个包装类，通过它可以对包装的 Resource 接口进行引用计数。每当引用增加的时候通过acquire（）对计数器加一，引用减少时通过release（）对计数器减一。当计数器为0的时候对资源进行回收。

### EngineResource创建过程

EngineResource正常创建有两个位置。

1. 当从文件或者网路加载成功的时候会通过EngineResourceFactory#build来创建对应的活动资源。
2. 当图片从Lru缓存中加载后，会因为需要将对应的资源放进ActiveResources而进行创建

```java
//toWrap 需要进行引用计数计算的资源
//isCacheable 是否能够被缓存  
//isRecyclable 是否已经被回收
EngineResource(Resource<Z> toWrap, boolean isCacheable, boolean isRecyclable) {
    resource = Preconditions.checkNotNull(toWrap);
    this.isCacheable = isCacheable;
    this.isRecyclable = isRecyclable;
  }
```

### EngineResource引用计数的加减

```java
//有使用的位置 进行加1
synchronized void acquire() {
    if (isRecycled) {
      throw new IllegalStateException("Cannot acquire a recycled resource");
    }
    ++acquired;
  }

  @SuppressWarnings("SynchronizeOnNonFinalField")
  void release() {
    synchronized (listener) {
      synchronized (this) {
        if (acquired <= 0) {
          throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
        }
         //有放弃使用的位置，减一  同时判断如果当前使用者的数量为0 那么将对应的活动资源进行回收
        if (--acquired == 0) {
            //listener 的实际对象是Engine
          listener.onResourceReleased(key, this);
        }
      }
    }
  }
```

## ActiveResources

ActiveResources内部通过一个Map弱引用的方式对EngineResource进行持有，从而避免内存泄漏。

```java
//ResourceWeakReference是ActiveResources的一个内部类，继承了WeakReference
final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
```

### ActiveResources的添加，删除，获取

```java
synchronized void activate(Key key, EngineResource<?> resource) {
    //构建一个新的存储对象
    ResourceWeakReference toPut =
        new ResourceWeakReference(
            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);

    ResourceWeakReference removed = activeEngineResources.put(key, toPut);
    if (removed != null) {
      removed.reset();
    }
  }

  synchronized void deactivate(Key key) {
    ResourceWeakReference removed = activeEngineResources.remove(key);
    if (removed != null) {
      removed.reset();
    }
  }

  @Nullable
  synchronized EngineResource<?> get(Key key) {
    ResourceWeakReference activeRef = activeEngineResources.get(key);
    if (activeRef == null) {
      return null;
    }
	
    EngineResource<?> active = activeRef.get();
      //如果弱引用持有的资源被回收，将对应的资源清除干净
    if (active == null) {
      cleanupActiveReference(activeRef);
    }
    return active;
  }
```

# 内存缓存

当请求被取消或者Request接收到生命周期调用onDestroy页面销毁的时候会通知Request请求释放活动资源

```java
//SingleRequst#clear
public synchronized void clear() {
    ...
    // 释放对应的活动资源
    if (resource != null) {
      releaseResource(resource);
    }
   	...
  }
```

releaseResource会通过Engine#release调用EngineResource#release 如果此时活动计数器的计数为0的话会设置的监听回调到Engine#onResourceReleased

```java
public synchronized void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
    //从活动资源中移除对应的资源
    activeResources.deactivate(cacheKey);
    //如果对应的resource 能够被缓存将其加入缓存中。
    if (resource.isCacheable()) {
      cache.put(cacheKey, resource);
    } else {
      resourceRecycler.recycle(resource);
    }
  }
```

## MemoryCache的实现

上面代码的cache是一个MemoryCache接口，

# Bitmap重用

# 串讲整个流程